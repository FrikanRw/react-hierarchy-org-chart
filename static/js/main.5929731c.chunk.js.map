{"version":3,"sources":["../../src/chartHelper/index.js","../../src/index.js","App.js","index.js"],"names":["d3","require","constructor","locateRecurve","d","ch","attrs","id","Math","svgWidth","svgHeight","marginTop","marginBottom","marginRight","marginLeft","container","defaultTextFill","nodeTextFill","defaultFont","backgroundColor","data","depth","duration","strokeWidth","dropShadowId","initialZoom","minMaxZoomProportions","behaviors","root","onNodeClick","this","Object","key","_","string","arguments","eval","params","selector","elementTag","selection","_children","nodeIdsStore","children","locate","calc","centerX","chartTopMargin","chartLeftMargin","chartWidth","chartHeight","width","height","layouts","treemap","zoom","e","nodeId","parentNodeId","directSubordinates","totalSubordinates","console","svg","tag","chart","filter","feMerge","DOM","node","nodeChildrenIds","getNodeChildrenIds","updateNodesState","bind","y","treeData","nodes","imageWidth","imageHeight","imageBorderColor","imageBorderWidth","imageRx","imageCenterTopDistance","imageCenterLeftDistance","borderColor","links","patternsSelection","linkSelection","linkUpdate","o","x","y0","linkEnter","nodesSelection","nodeEnter","x0","nodeImageGroups","nodeUpdate","fo","nodeButtonGroups","param","nodeExitTransition","normalizedTochartX","normalizedTochartY","newX","newY","t","window","alpha","red","green","blue","s","ex","ey","xrvs","yrvs","rInitial","r","h","w","parent","transform","OrganisationalChart","d3Container","useRef","useState","useLayoutEffect","newChart","setChart","ref","value","onChange","setId","onClick","App","state","setstate","useEffect","then","log","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5929731c.chunk.js","sourcesContent":["const d3 = require('d3')\n\nclass TreeChart {\n  constructor() {\n    // Exposed variables\n    const attrs = {\n      id: `ID${Math.floor(Math.random() * 1000000)}`, // Id for event handlings\n      svgWidth: 100,\n      svgHeight: 100,\n      marginTop: 0,\n      marginBottom: 0,\n      marginRight: 0,\n      marginLeft: 0,\n      container: 'body',\n      defaultTextFill: '#2C3E50',\n      nodeTextFill: 'white',\n      defaultFont: 'Helvetica',\n      backgroundColor: '#fafafa',\n      data: null,\n      depth: 180,\n      duration: 600,\n      strokeWidth: 3,\n      dropShadowId: null,\n      initialZoom: 1,\n      minMaxZoomProportions: [0.05, 3],\n      behaviors: null,\n      root: {},\n      onNodeClick: (d) => d\n    }\n\n    this.getChartState = () => attrs\n\n    // Dynamically set getter and setter functions for Chart class\n    Object.keys(attrs).forEach((key) => {\n      this[key] = function (_) {\n        var string = `attrs['${key}'] = _`\n        if (!arguments.length) {\n          return eval(`attrs['${key}'];`)\n        }\n        eval(string)\n        return this\n      }\n    })\n\n    this.initializeEnterExitUpdatePattern()\n  }\n\n  initializeEnterExitUpdatePattern() {\n    d3.selection.prototype.patternify = function (params) {\n      var container = this\n      var selector = params.selector\n      var elementTag = params.tag\n      var data = params.data || [selector]\n\n      // Pattern in action\n      var selection = container.selectAll('.' + selector).data(data, (d, i) => {\n        if (typeof d === 'object') {\n          if (d.id) {\n            return d.id\n          }\n        }\n        return i\n      })\n      selection.exit().remove()\n      selection = selection.enter().append(elementTag).merge(selection)\n      selection.attr('class', selector)\n      return selection\n    }\n  }\n\n  // This method retrieves passed node's children IDs (including node)\n  getNodeChildrenIds({ data, children, _children }, nodeIdsStore) {\n    // Store current node ID\n    nodeIdsStore.push(data.nodeId)\n\n    // Loop over children and recursively store descendants id (expanded nodes)\n    if (children) {\n      children.forEach((d) => {\n        this.getNodeChildrenIds(d, nodeIdsStore)\n      })\n    }\n\n    // Loop over _children and recursively store descendants id (collapsed nodes)\n    if (_children) {\n      _children.forEach((d) => {\n        this.getNodeChildrenIds(d, nodeIdsStore)\n      })\n    }\n\n    // Return result\n    return nodeIdsStore\n  }\n\n  locateRecursive = (d, id) => {\n    const locateRecurve = this.locateRecursive\n\n    if (d.id === id) {\n      this.expandParents(d)\n    } else if (d._children) {\n      d._children.forEach(function (ch) {\n        ch.parent = d\n        locateRecurve(ch, id)\n      })\n    } else if (d.children) {\n      d.children.forEach(function (ch) {\n        ch.parent = d\n        locateRecurve(ch, id)\n      })\n    }\n  }\n\n  locate(id) {\n    const attrs = this.getChartState()\n    const locateRecurve = this.locateRecursive\n    /* collapse all and expand logged user nodes */\n    if (!attrs.root.children) {\n      if (!attrs.root.id === id) {\n        attrs.root.children = attrs.root._children\n      }\n    }\n    if (attrs.root.children) {\n      attrs.root.children.forEach(this.collapse)\n      attrs.root.children.forEach(function (ch) {\n        locateRecurve(ch, id)\n      })\n    }\n\n    this.update(attrs.root, { locate: id })\n  }\n\n  // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale\n  setZoomFactor(zoomLevel) {\n    const attrs = this.getChartState()\n    const calc = attrs.calc\n\n    // Store passed zoom level\n    attrs.initialZoom = zoomLevel\n\n    // Rescale container element accordingly\n    attrs.centerG.attr(\n      'transform',\n      ` translate(${calc.centerX}, ${calc.nodeMaxHeight / 2}) scale(${\n        attrs.initialZoom\n      })`\n    )\n  }\n\n  render() {\n    // InnerFunctions which will update visuals\n\n    const attrs = this.getChartState()\n    const thisObjRef = this\n    // Drawing containers\n    const container = d3.select(attrs.container)\n    const containerRect = container.node().getBoundingClientRect()\n    // if (containerRect.width > 0) attrs.svgWidth = containerRect.width\n\n    // Attach drop shadow id to attrs object\n    this.setDropShadowId(attrs)\n\n    // Calculated properties\n    const calc = {\n      id: null,\n      chartTopMargin: null,\n      chartLeftMargin: null,\n      chartWidth: null,\n      chartHeight: null\n    }\n    calc.id = `ID${Math.floor(Math.random() * 1000000)}` // id for event handlings\n    calc.chartLeftMargin = attrs.marginLeft\n    calc.chartTopMargin = attrs.marginTop\n    calc.chartWidth = attrs.svgWidth - attrs.marginRight - calc.chartLeftMargin\n    calc.chartHeight =\n      attrs.svgHeight - attrs.marginBottom - calc.chartTopMargin\n\n    // Get maximum node width and height\n    calc.nodeMaxWidth = d3.max(attrs.data, ({ width }) => width)\n    calc.nodeMaxHeight = d3.max(attrs.data, ({ height }) => height)\n\n    // Calculate max node depth (it's needed for layout heights calculation)\n    attrs.depth = calc.nodeMaxHeight + 100\n    calc.centerX = calc.chartWidth / 2\n    attrs.calc = calc\n    //* *******************  LAYOUTS  ***********************\n    const layouts = {\n      treemap: null\n    }\n    attrs.layouts = layouts\n\n    // Generate tree layout function\n    layouts.treemap = d3\n      .tree()\n      .size([calc.chartWidth, calc.chartHeight])\n      .nodeSize([calc.nodeMaxWidth + 100, calc.nodeMaxHeight + attrs.depth])\n\n    // ******************* BEHAVIORS . **********************\n    const behaviors = {\n      zoom: null\n    }\n\n    // Get zooming function\n    behaviors.zoom = d3.zoom().on('zoom', (e) => this.zoomed(e))\n\n    attrs.behaviors = behaviors\n    //* ***************** ROOT node work ************************\n\n    // Convert flat data to hierarchical\n    attrs.root = d3\n      .stratify()\n      .id(({ nodeId }) => nodeId)\n      .parentId(({ parentNodeId }) => parentNodeId)(attrs.data)\n\n    // Set child nodes enter appearance positions\n    attrs.root.x0 = 0\n    attrs.root.y0 = 0\n\n    /** Get all nodes as array (with extended parent & children properties set)\n            This way we can access any node's parent directly using node.parent - pretty cool, huh?\n        */\n    attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants()\n\n    // Assign direct children and total subordinate children's cound\n    attrs.allNodes.forEach((d) => {\n      Object.assign(d.data, {\n        directSubordinates: d.children ? d.children.length : 0,\n        totalSubordinates: d.descendants().length - 1\n      })\n    })\n\n    // Collapse all children at first\n    attrs.root.children.forEach((d) => this.collapse(d))\n\n    // Then expand some nodes, which have `expanded` property set\n    attrs.root.children.forEach((d) => this.expandSomeNodes(d))\n\n    // *************************  DRAWING **************************\n    // Add svg\n    console.log('svg', attrs.svgWidth, attrs.svgHeight)\n    const svg = container\n      .patternify({\n        tag: 'svg',\n        selector: 'svg-chart-container'\n      })\n      .attr('width', attrs.svgWidth)\n      .attr('height', attrs.svgHeight)\n      .attr('font-family', attrs.defaultFont)\n      .call(behaviors.zoom)\n      .attr('cursor', 'move')\n      .style('background-color', attrs.backgroundColor)\n    attrs.svg = svg\n\n    // Add container g element\n    const chart = svg\n      .patternify({\n        tag: 'g',\n        selector: 'chart'\n      })\n      .attr(\n        'transform',\n        `translate(${calc.chartLeftMargin},${calc.chartTopMargin})`\n      )\n\n    // Add one more container g element, for better positioning controls\n    attrs.centerG = chart\n      .patternify({\n        tag: 'g',\n        selector: 'center-group'\n      })\n      .attr(\n        'transform',\n        `translate(${calc.centerX},${calc.nodeMaxHeight / 2}) scale(${\n          attrs.initialZoom\n        })`\n      )\n\n    attrs.chart = chart\n\n    // ************************** ROUNDED AND SHADOW IMAGE  WORK USING SVG FILTERS **********************\n\n    // Adding defs element for rounded image\n    attrs.defs = svg.patternify({\n      tag: 'defs',\n      selector: 'image-defs'\n    })\n\n    // Adding defs element for image's shadow\n    const filterDefs = svg.patternify({\n      tag: 'defs',\n      selector: 'filter-defs'\n    })\n\n    // Adding shadow element - (play with svg filter here - https://bit.ly/2HwnfyL)\n    const filter = filterDefs\n      .patternify({\n        tag: 'filter',\n        selector: 'shadow-filter-element'\n      })\n      .attr('id', attrs.dropShadowId)\n      .attr('y', `${-50}%`)\n      .attr('x', `${-50}%`)\n      .attr('height', `${200}%`)\n      .attr('width', `${200}%`)\n\n    // Add gaussian blur element for shadows - we can control shadow length with this\n    filter\n      .patternify({\n        tag: 'feGaussianBlur',\n        selector: 'feGaussianBlur-element'\n      })\n      .attr('in', 'SourceAlpha')\n      .attr('stdDeviation', 3.1)\n      .attr('result', 'blur')\n\n    // Add fe-offset element for shadows -  we can control shadow positions with it\n    filter\n      .patternify({\n        tag: 'feOffset',\n        selector: 'feOffset-element'\n      })\n      .attr('in', 'blur')\n      .attr('result', 'offsetBlur')\n      .attr('dx', 4.28)\n      .attr('dy', 4.48)\n      .attr('x', 8)\n      .attr('y', 8)\n\n    // Add fe-flood element for shadows - we can control shadow color and opacity with this element\n    filter\n      .patternify({\n        tag: 'feFlood',\n        selector: 'feFlood-element'\n      })\n      .attr('in', 'offsetBlur')\n      .attr('flood-color', 'black')\n      .attr('flood-opacity', 0.3)\n      .attr('result', 'offsetColor')\n\n    // Add feComposite element for shadows\n    filter\n      .patternify({\n        tag: 'feComposite',\n        selector: 'feComposite-element'\n      })\n      .attr('in', 'offsetColor')\n      .attr('in2', 'offsetBlur')\n      .attr('operator', 'in')\n      .attr('result', 'offsetBlur')\n\n    // Add feMerge element for shadows\n    const feMerge = filter.patternify({\n      tag: 'feMerge',\n      selector: 'feMerge-element'\n    })\n\n    // Add feMergeNode element for shadows\n    feMerge\n      .patternify({\n        tag: 'feMergeNode',\n        selector: 'feMergeNode-blur'\n      })\n      .attr('in', 'offsetBlur')\n\n    // Add another feMergeNode element for shadows\n    feMerge\n      .patternify({\n        tag: 'feMergeNode',\n        selector: 'feMergeNode-graphic'\n      })\n      .attr('in', 'SourceGraphic')\n\n    // Display tree contenrs\n    this.update(attrs.root)\n\n    // #########################################  UTIL FUNCS ##################################\n    // This function restyles foreign object elements ()\n\n    d3.select(window).on(`resize.${attrs.id}`, () => {\n      const containerRect = container.node().getBoundingClientRect()\n      //  if (containerRect.width > 0) attrs.svgWidth = containerRect.width;\n      //\tmain();\n    })\n\n    return this\n  }\n\n  // This function sets drop shadow ID to the passed object\n  setDropShadowId(d) {\n    // If it's already set, then return\n    if (d.dropShadowId) return\n\n    // Generate drop shadow ID\n    let id = `${d.id}-drop-shadow`\n\n    // If DOM object is available, then use UID method to generated shadow id\n    // @ts-ignore\n    if (typeof DOM !== 'undefined') {\n      // @ts-ignore\n      id = DOM.uid(d.id).id\n    }\n\n    // Extend passed object with drop shadow ID\n    Object.assign(d, {\n      dropShadowId: id\n    })\n  }\n\n  // This function can be invoked via chart.addNode API, and it adds node in tree at runtime\n  addNode(obj) {\n    const attrs = this.getChartState()\n    attrs.data.push(obj)\n\n    // Update state of nodes and redraw graph\n    this.updateNodesState()\n    return this\n  }\n\n  // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime\n  removeNode(nodeId) {\n    const attrs = this.getChartState()\n    const node = attrs.allNodes.filter(({ data }) => data.nodeId == nodeId)[0]\n\n    // Remove all node childs\n    if (node) {\n      // Retrieve all children nodes ids (including current node itself)\n      const nodeChildrenIds = this.getNodeChildrenIds(node, [])\n\n      // Filter out retrieved nodes and reassign data\n      attrs.data = attrs.data.filter((d) => !nodeChildrenIds.includes(d.nodeId))\n\n      const updateNodesState = this.updateNodesState.bind(this)\n      // Update state of nodes and redraw graph\n      updateNodesState()\n    }\n  }\n\n  // This function basically redraws visible graph, based on nodes state\n  update({ x0, y0, x, y }, param) {\n    const attrs = this.getChartState()\n    const calc = attrs.calc\n\n    //  Assigns the x and y position for the nodes\n    const treeData = attrs.layouts.treemap(attrs.root)\n\n    // Get tree nodes and links and attach some properties\n    const nodes = treeData.descendants().map((d) => {\n      // If at least one property is already set, then we don't want to reset other properties\n      if (d.width) return d\n\n      // Declare properties with deffault values\n      let imageWidth = 100\n      let imageHeight = 100\n      let imageBorderColor = 'steelblue'\n      let imageBorderWidth = 0\n      let imageRx = 0\n      let imageCenterTopDistance = 0\n      let imageCenterLeftDistance = 0\n      let borderColor = 'steelblue'\n      let backgroundColor = 'steelblue'\n      const width = d.data.width\n      const height = d.data.height\n      let dropShadowId = `none`\n\n      // Override default values based on data\n      if (d.data.nodeImage && d.data.nodeImage.shadow) {\n        dropShadowId = `url(#${attrs.dropShadowId})`\n      }\n      if (d.data.nodeImage && d.data.nodeImage.width) {\n        imageWidth = d.data.nodeImage.width\n      }\n      if (d.data.nodeImage && d.data.nodeImage.height) {\n        imageHeight = d.data.nodeImage.height\n      }\n      if (d.data.nodeImage && d.data.nodeImage.borderColor) {\n        imageBorderColor = this.rgbaObjToColor(d.data.nodeImage.borderColor)\n      }\n      if (d.data.nodeImage && d.data.nodeImage.borderWidth) {\n        imageBorderWidth = d.data.nodeImage.borderWidth\n      }\n      if (d.data.nodeImage && d.data.nodeImage.centerTopDistance) {\n        imageCenterTopDistance = d.data.nodeImage.centerTopDistance\n      }\n      if (d.data.nodeImage && d.data.nodeImage.centerLeftDistance) {\n        imageCenterLeftDistance = d.data.nodeImage.centerLeftDistance\n      }\n      if (d.data.borderColor) {\n        borderColor = this.rgbaObjToColor(d.data.borderColor)\n      }\n      if (d.data.backgroundColor) {\n        backgroundColor = this.rgbaObjToColor(d.data.backgroundColor)\n      }\n      if (\n        d.data.nodeImage &&\n        d.data.nodeImage.cornerShape.toLowerCase() === 'circle'\n      ) {\n        imageRx = Math.max(imageWidth, imageHeight)\n      }\n      if (\n        d.data.nodeImage &&\n        d.data.nodeImage.cornerShape.toLowerCase() === 'rounded'\n      ) {\n        imageRx = Math.min(imageWidth, imageHeight) / 6\n      }\n\n      // Extend node object with calculated properties\n      return Object.assign(d, {\n        imageWidth,\n        imageHeight,\n        imageBorderColor,\n        imageBorderWidth,\n        borderColor,\n        backgroundColor,\n        imageRx,\n        width,\n        height,\n        imageCenterTopDistance,\n        imageCenterLeftDistance,\n        dropShadowId\n      })\n    })\n\n    // Get all links\n    const links = treeData.descendants().slice(1)\n\n    // Set constant depth for each nodes\n    nodes.forEach((d) => (d.y = d.depth * attrs.depth))\n\n    // ------------------- FILTERS ---------------------\n\n    // Add patterns for each node (it's needed for rounded image implementation)\n    const patternsSelection = attrs.defs\n      .selectAll('.pattern')\n      .data(nodes, ({ id }) => id)\n\n    // Define patterns enter selection\n    const patternEnterSelection = patternsSelection.enter().append('pattern')\n\n    // Patters update selection\n    const patterns = patternEnterSelection\n      .merge(patternsSelection)\n      .attr('class', 'pattern')\n      .attr('height', 1)\n      .attr('width', 1)\n      .attr('id', ({ id }) => id)\n\n    // Add images to patterns\n    const patternImages = patterns\n      .patternify({\n        tag: 'image',\n        selector: 'pattern-image',\n        data: (d) => [d]\n      })\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('height', ({ imageWidth }) => imageWidth)\n      .attr('width', ({ imageHeight }) => imageHeight)\n      .attr('xlink:href', ({ data }) => data.nodeImage && data.nodeImage.url)\n      .attr(\n        'viewbox',\n        ({ imageWidth, imageHeight }) => `0 0 ${imageWidth * 2} ${imageHeight}`\n      )\n      .attr('preserveAspectRatio', 'xMidYMin slice')\n\n    // Remove patterns exit selection after animation\n    patternsSelection.exit().transition().duration(attrs.duration).remove()\n\n    // --------------------------  LINKS ----------------------\n    // Get links selection\n    const linkSelection = attrs.centerG\n      .selectAll('path.link')\n      .data(links, ({ id }) => id)\n\n    // Enter any new links at the parent's previous position.\n    const linkEnter = linkSelection\n      .enter()\n      .insert('path', 'g')\n      .attr('class', 'link')\n      .attr('d', (d) => {\n        const o = {\n          x: x0,\n          y: y0\n        }\n        return this.diagonal(o, o)\n      })\n\n    // Get links update selection\n    const linkUpdate = linkEnter.merge(linkSelection)\n\n    // Styling links\n    linkUpdate\n      .attr('fill', 'none')\n      .attr('stroke-width', ({ data }) => data.connectorLineWidth || 2)\n      .attr('stroke', ({ data }) => {\n        if (data.connectorLineColor) {\n          return this.rgbaObjToColor(data.connectorLineColor)\n        }\n        return 'green'\n      })\n      .attr('stroke-dasharray', ({ data }) => {\n        if (data.dashArray) {\n          return data.dashArray\n        }\n        return ''\n      })\n\n    // Transition back to the parent element position\n    linkUpdate\n      .transition()\n      .duration(attrs.duration)\n      .attr('d', (d) => this.diagonal(d, d.parent))\n\n    // Remove any  links which is exiting after animation\n    const linkExit = linkSelection\n      .exit()\n      .transition()\n      .duration(attrs.duration)\n      .attr('d', (d) => {\n        const o = {\n          x: x,\n          y: y\n        }\n        return this.diagonal(o, o)\n      })\n      .remove()\n\n    // --------------------------  NODES ----------------------\n    // Get nodes selection\n    const nodesSelection = attrs.centerG\n      .selectAll('g.node')\n      .data(nodes, ({ id }) => id)\n\n    // Enter any new nodes at the parent's previous position.\n    const nodeEnter = nodesSelection\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .attr('transform', (d) => `translate(${x0},${y0})`)\n      .attr('cursor', 'pointer')\n      .on('click', ({ data }) => {\n        if ([...d3.event.srcElement.classList].includes('node-button-circle')) {\n          return\n        }\n        attrs.onNodeClick(data.nodeId)\n      })\n\n    // Add background rectangle for the nodes\n    nodeEnter\n      .patternify({\n        tag: 'rect',\n        selector: 'node-rect',\n        data: (d) => [d]\n      })\n      .style('fill', ({ _children }) => (_children ? 'lightsteelblue' : '#fff'))\n\n    // Defined node images wrapper group\n    const nodeImageGroups = nodeEnter.patternify({\n      tag: 'g',\n      selector: 'node-image-group',\n      data: (d) => [d]\n    })\n\n    // Add background rectangle for node image\n    nodeImageGroups.patternify({\n      tag: 'rect',\n      selector: 'node-image-rect',\n      data: (d) => [d]\n    })\n\n    // Node update styles\n    const nodeUpdate = nodeEnter\n      .merge(nodesSelection)\n      .style('font', '12px sans-serif')\n\n    // Add foreignObject element inside rectangle\n    const fo = nodeUpdate.patternify({\n      tag: 'foreignObject',\n      selector: 'node-foreign-object',\n      data: (d) => [d]\n    })\n\n    // Add foreign object\n    fo.patternify({\n      tag: 'xhtml:div',\n      selector: 'node-foreign-object-div',\n      data: (d) => [d]\n    })\n\n    this.restyleForeignObjectElements()\n\n    // Add Node button circle's group (expand-collapse button)\n    const nodeButtonGroups = nodeEnter\n      .patternify({\n        tag: 'g',\n        selector: 'node-button-g',\n        data: (d) => [d]\n      })\n      .on('click', (d) => this.onButtonClick(d))\n\n    // Add expand collapse button circle\n    nodeButtonGroups.patternify({\n      tag: 'circle',\n      selector: 'node-button-circle',\n      data: (d) => [d]\n    })\n\n    // Add button text\n    nodeButtonGroups\n      .patternify({\n        tag: 'text',\n        selector: 'node-button-text',\n        data: (d) => [d]\n      })\n      .attr('pointer-events', 'none')\n\n    // Transition to the proper position for the node\n    nodeUpdate\n      .transition()\n      .attr('opacity', 0)\n      .duration(attrs.duration)\n      .attr('transform', ({ x, y }) => `translate(${x},${y})`)\n      .attr('opacity', 1)\n\n    // Move images to desired positions\n    nodeUpdate\n      .selectAll('.node-image-group')\n      .attr('transform', ({ imageWidth, width, imageHeight, height }) => {\n        const x = -imageWidth / 2 - width / 2\n        const y = -imageHeight / 2 - height / 2\n        return `translate(${x},${y})`\n      })\n\n    // Style node image rectangles\n    nodeUpdate\n      .select('.node-image-rect')\n      .attr('fill', ({ id }) => `url(#${id})`)\n      .attr('width', ({ imageWidth }) => imageWidth)\n      .attr('height', ({ imageHeight }) => imageHeight)\n      .attr('stroke', ({ imageBorderColor }) => imageBorderColor)\n      .attr('stroke-width', ({ imageBorderWidth }) => imageBorderWidth)\n      .attr('rx', ({ imageRx }) => imageRx)\n      .attr('y', ({ imageCenterTopDistance }) => imageCenterTopDistance)\n      .attr('x', ({ imageCenterLeftDistance }) => imageCenterLeftDistance)\n      .attr('filter', ({ dropShadowId }) => dropShadowId)\n\n    // Style node rectangles\n    nodeUpdate\n      .select('.node-rect')\n      .attr('width', ({ data }) => data.width)\n      .attr('height', ({ data }) => data.height)\n      .attr('x', ({ data }) => -data.width / 2)\n      .attr('y', ({ data }) => -data.height / 2)\n      .attr('rx', ({ data }) => data.borderRadius || 0)\n      .attr('stroke-width', ({ data }) => {\n        if (param && data.nodeId === param.locate) {\n          return '5'\n        }\n        return data.borderWidth || attrs.strokeWidth\n      })\n      .attr('cursor', 'pointer')\n      .attr('stroke', ({ borderColor, data }) => {\n        if (param && data.nodeId === param.locate) {\n          return '#ff0000'\n        }\n        return borderColor\n      })\n      .attr('id', ({ data }) => data.nodeId)\n      .style('fill', ({ backgroundColor }) => backgroundColor)\n\n    // Move node button group to the desired position\n    nodeUpdate\n      .select('.node-button-g')\n      .attr('transform', ({ data }) => `translate(0,${data.height / 2})`)\n      .attr('opacity', ({ children, _children }) => {\n        if (children || _children) {\n          return 1\n        }\n        return 0\n      })\n\n    // Restyle node button circle\n    nodeUpdate\n      .select('.node-button-circle')\n      .attr('r', 16)\n      .attr('stroke-width', ({ data }) => data.borderWidth || attrs.strokeWidth)\n      .attr('fill', attrs.backgroundColor)\n      .attr('stroke', ({ borderColor }) => borderColor)\n\n    // Restyle button texts\n    nodeUpdate\n      .select('.node-button-text')\n      .attr('text-anchor', 'middle')\n      .attr('alignment-baseline', 'middle')\n      .attr('fill', attrs.defaultTextFill)\n      .attr('font-size', ({ children }) => {\n        if (children) return 40\n        return 26\n      })\n      .text(({ children }) => {\n        if (children) return '-'\n        return '+'\n      })\n      .attr('y', 0)\n\n    // Remove any exiting nodes after transition\n    const nodeExitTransition = nodesSelection\n      .exit()\n      .attr('opacity', 1)\n      .transition()\n      .duration(attrs.duration)\n      .attr('transform', (d) => `translate(${x},${y})`)\n      .on('end', function () {\n        d3.select(this).remove()\n      })\n      .attr('opacity', 0)\n\n    // On exit reduce the node rects size to 0\n    nodeExitTransition\n      .selectAll('.node-rect')\n      .attr('width', 10)\n      .attr('height', 10)\n      .attr('x', 0)\n      .attr('y', 0)\n\n    // On exit reduce the node image rects size to 0\n    nodeExitTransition\n      .selectAll('.node-image-rect')\n      .attr('width', 10)\n      .attr('height', 10)\n      .attr('x', ({ width }) => width / 2)\n      .attr('y', ({ height }) => height / 2)\n\n    // Store the old positions for transition.\n    nodes.forEach((d) => {\n      d.x0 = d.x\n      d.y0 = d.y\n    })\n    // navigate to located node\n\n    if (param && param.locate) {\n      let x\n      let y\n      nodes.forEach(function (d) {\n        if (d.id === param.locate) {\n          x = d.x\n          y = d.y\n        }\n      })\n      const newZoom = 2\n      const normalizedTochartX = x * attrs.initialZoom + attrs.calc.centerX\n      const normalizedTochartY =\n        y * attrs.initialZoom + attrs.calc.nodeMaxHeight / 2\n\n      const newX = -normalizedTochartX * newZoom + attrs.svgWidth / 2\n      const newY = -normalizedTochartY * newZoom + attrs.svgHeight / 2\n      const t = d3.zoomIdentity.translate(newX, newY).scale(newZoom)\n\n      attrs.svg\n        .transition()\n        .duration(attrs.duration)\n        .call(attrs.behaviors.zoom.transform, t)\n    }\n  }\n\n  redraw() {\n    const attrs = this.getChartState()\n    // console.log(\"here\", d3.event.translate, d3.event.scale);\n    attrs.svg.attr(\n      'transform',\n      'translate(' + d3.event.translate + ')' + ' scale(' + d3.event.scale + ')'\n    )\n  }\n\n  // This function detects whether current browser is edge\n  isEdge() {\n    return window.navigator.userAgent.includes('Edge')\n  }\n\n  /* Function converts rgba objects to rgba color string \n      {red:110,green:150,blue:255,alpha:1}  => rgba(110,150,255,1)\n    */\n  rgbaObjToColor({ red, green, blue, alpha }) {\n    return `rgba(${red},${green},${blue},${alpha})`\n  }\n\n  // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges?collection=@bumbeishvili/work-components\n  diagonal(s, t) {\n    // Calculate some variables based on source and target (s,t) coordinates\n    const x = s.x\n    const y = s.y\n    const ex = t.x\n    const ey = t.y\n    const xrvs = ex - x < 0 ? -1 : 1\n    const yrvs = ey - y < 0 ? -1 : 1\n    const rdef = 35\n    const rInitial = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef\n    const r = Math.abs(ey - y) / 2 < rInitial ? Math.abs(ey - y) / 2 : rInitial\n    const h = Math.abs(ey - y) / 2 - r\n    const w = Math.abs(ex - x) - r * 2\n\n    // Build the path\n    const path = `\n             M ${x} ${y}\n             L ${x} ${y + h * yrvs}\n             C  ${x} ${y + h * yrvs + r * yrvs} ${x} ${\n      y + h * yrvs + r * yrvs\n    } ${x + r * xrvs} ${y + h * yrvs + r * yrvs}\n             L ${x + w * xrvs + r * xrvs} ${y + h * yrvs + r * yrvs}\n             C ${ex}  ${y + h * yrvs + r * yrvs} ${ex}  ${\n      y + h * yrvs + r * yrvs\n    } ${ex} ${ey - h * yrvs}\n             L ${ex} ${ey}\n           `\n    // Return result\n    return path\n  }\n\n  restyleForeignObjectElements() {\n    const attrs = this.getChartState()\n\n    attrs.svg\n      .selectAll('.node-foreign-object')\n      .attr('width', ({ width }) => width)\n      .attr('height', ({ height }) => height)\n      .attr('x', ({ width }) => -width / 2)\n      .attr('y', ({ height }) => -height / 2)\n    attrs.svg\n      .selectAll('.node-foreign-object-div')\n      .style('width', ({ width }) => `${width}px`)\n      .style('height', ({ height }) => `${height}px`)\n      .style('color', 'white')\n      .html(({ data }) => data.template)\n  }\n\n  // Toggle children on click.\n  onButtonClick(d) {\n    // If childrens are expanded\n    if (d.children) {\n      // Collapse them\n      d._children = d.children\n      d.children = null\n\n      // Set descendants expanded property to false\n      this.setExpansionFlagToChildren(d, false)\n    } else {\n      // Expand children\n      d.children = d._children\n      d._children = null\n\n      // Set each children as expanded\n      d.children.forEach(({ data }) => (data.expanded = true))\n    }\n\n    // Redraw Graph\n    this.update(d)\n  }\n\n  // This function changes `expanded` property to descendants\n  setExpansionFlagToChildren({ data, children, _children }, flag) {\n    // Set flag to the current property\n    data.expanded = flag\n\n    // Loop over and recursively update expanded children's descendants\n    if (children) {\n      children.forEach((d) => {\n        this.setExpansionFlagToChildren(d, flag)\n      })\n    }\n\n    // Loop over and recursively update collapsed children's descendants\n    if (_children) {\n      _children.forEach((d) => {\n        this.setExpansionFlagToChildren(d, flag)\n      })\n    }\n  }\n\n  // This function can be invoked via chart.setExpanded API, it expands or collapses particular node\n  setExpanded(id, expandedFlag) {\n    const attrs = this.getChartState()\n    // Retrieve node by node Id\n    const node = attrs.allNodes.filter(({ data }) => data.nodeId == id)[0]\n\n    // If node exists, set expansion flag\n    if (node) node.data.expanded = expandedFlag\n\n    // First expand all nodes\n    attrs.root.children.forEach((d) => this.expand(d))\n\n    // Then collapse all nodes\n    attrs.root.children.forEach((d) => this.collapse(d))\n\n    // Then expand only the nodes, which were previously expanded, or have an expand flag set\n    attrs.root.children.forEach((d) => this.expandSomeNodes(d))\n\n    // Redraw graph\n    this.update(attrs.root)\n  }\n\n  // Method which only expands nodes, which have property set \"expanded=true\"\n  expandSomeNodes(d) {\n    // If node has expanded property set\n    if (d.data.expanded) {\n      // Retrieve node's parent\n      let parent = d.parent\n\n      // While we can go up\n      while (parent) {\n        // Expand all current parent's children\n        if (parent._children) {\n          parent.children = parent._children\n        }\n\n        // Replace current parent holding object\n        parent = parent.parent\n      }\n    }\n\n    // Recursivelly do the same for collapsed nodes\n    if (d._children) {\n      d._children.forEach((ch) => this.expandSomeNodes(ch))\n    }\n\n    // Recursivelly do the same for expanded nodes\n    if (d.children) {\n      d.children.forEach((ch) => this.expandSomeNodes(ch))\n    }\n  }\n\n  // This function updates nodes state and redraws graph, usually after data change\n  updateNodesState() {\n    const attrs = this.getChartState()\n    // Store new root by converting flat data to hierarchy\n    attrs.root = d3\n      .stratify()\n      .id(({ nodeId }) => nodeId)\n      .parentId(({ parentNodeId }) => parentNodeId)(attrs.data)\n\n    // Store positions, where children appear during their enter animation\n    attrs.root.x0 = 0\n    attrs.root.y0 = 0\n\n    // Store all nodes in flat format (although, now we can browse parent, see depth e.t.c. )\n    attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants()\n\n    // Store direct and total descendants count\n    attrs.allNodes.forEach((d) => {\n      Object.assign(d.data, {\n        directSubordinates: d.children ? d.children.length : 0,\n        totalSubordinates: d.descendants().length - 1\n      })\n    })\n\n    // Expand all nodes first\n    attrs.root.children.forEach(this.expand)\n\n    // Then collapse them all\n    attrs.root.children.forEach((d) => this.collapse(d))\n\n    // Then only expand nodes, which have expanded proprty set to true\n    attrs.root.children.forEach((ch) => this.expandSomeNodes(ch))\n\n    // Redraw Graphs\n    this.update(attrs.root)\n  }\n\n  // Function which collapses passed node and it's descendants\n  collapse = (d) => {\n    if (d.children) {\n      d._children = d.children\n      d._children.forEach((ch) => this.collapse(ch))\n      d.children = null\n    }\n  }\n\n  // Function which expands passed node and it's descendants\n  expand(d) {\n    if (d._children) {\n      d.children = d._children\n      d.children.forEach((ch) => this.expand(ch))\n      d._children = null\n    }\n  }\n\n  findmySelf(d) {\n    if (d.isLoggedUser) {\n      this.expandParents(d)\n    } else if (d._children) {\n      d._children.forEach(function (ch) {\n        ch.parent = d\n        this.findmySelf(ch)\n      })\n    } else if (d.children) {\n      d.children.forEach(function (ch) {\n        ch.parent = d\n        this.findmySelf(ch)\n      })\n    }\n  }\n\n  expandParents = (d) => {\n    while (d.parent) {\n      d = d.parent\n      if (!d.children) {\n        d.children = d._children\n        d._children = null\n      }\n    }\n  }\n\n  // Zoom handler function\n  zoomed() {\n    const attrs = this.getChartState()\n    const chart = attrs.chart\n\n    // Get d3 event's transform object\n    const transform = d3.event.transform\n\n    // Store it\n    attrs.lastTransform = transform\n    chart.attr('transform', transform)\n\n    // Apply new styles to the foreign object element\n    if (this.isEdge()) {\n      this.restyleForeignObjectElements()\n    }\n  }\n\n  // Added helper functions\n}\n\nexport default TreeChart\n","import React, { useLayoutEffect, useRef, useState } from 'react'\nimport TreeChart from './chartHelper/index'\nimport styles from './styles.module.css'\n\nexport const OrganisationalChart = ({ data, onNodeClick }) => {\n  const d3Container = useRef(null)\n  const [chart, setChart] = useState(null)\n  const [id, setId] = useState('O-498')\n\n  useLayoutEffect(() => {\n    if (data && d3Container.current) {\n      let newChart\n      if (!chart) {\n        newChart = new TreeChart()\n      }\n      console.log(data)\n\n      newChart\n        .container(d3Container.current)\n        .data(data)\n        .svgWidth(1000)\n        .svgHeight(500)\n        .initialZoom(0.4)\n        .onNodeClick((d) => {\n          console.log(d + ' node clicked')\n          onNodeClick(d)\n        })\n        .render()\n      setChart(newChart)\n    }\n  }, [data, d3Container.current])\n  if (chart) {\n    console.log(chart)\n    // chart.locate('O-917')\n  }\n  return (\n    <div>\n      <div ref={d3Container} />\n      <input\n        value={id}\n        onChange={(e) => {\n          setId(`${e.target.value}`)\n        }}\n      />\n      <button onClick={() => chart.locate(id)}>Locate</button>\n    </div>\n  )\n}\n","import React, {useEffect, useState} from 'react'\nimport * as d3 from 'd3';\nimport { OrganisationalChart } from 'react-hierarchy-org-chart'\nimport 'react-hierarchy-org-chart/dist/index.css'\n\nconst App = () => {\nconst [state, setstate] = useState(null)\n  useEffect(() => {\n    d3.json(\n      'https://gist.githubusercontent.com/bumbeishvili/dc0d47bc95ef359fdc75b63cd65edaf2/raw/c33a3a1ef4ba927e3e92b81600c8c6ada345c64b/orgChart.json',\n    ).then(data => {\n      setstate(data);\n    });\n  }, []);\n\n\n  return <OrganisationalChart \n  data={state}\n  onNodeClick={node=>console.log(node)} />\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}