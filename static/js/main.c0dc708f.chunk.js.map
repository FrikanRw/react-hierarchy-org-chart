{"version":3,"sources":["../../src/chartHelper/index.js","../../src/index.js","App.js","index.js"],"names":["d3","require","TreeChart","locateRecurve","d","ch","attrs","id","Math","svgWidth","svgHeight","marginTop","marginBottom","marginRight","marginLeft","container","defaultTextFill","nodeTextFill","defaultFont","backgroundColor","data","depth","duration","strokeWidth","dropShadowId","initialZoom","minMaxZoomProportions","behaviors","root","onNodeClick","this","Object","_","string","arguments","eval","initializeEnterExitUpdatePattern","params","selector","elementTag","selection","getNodeChildrenIds","children","_children","nodeIdsStore","locate","setZoomFactor","calc","render","chartTopMargin","chartLeftMargin","chartWidth","chartHeight","layouts","treemap","zoom","directSubordinates","totalSubordinates","console","svg","tag","chart","filter","feMerge","setDropShadowId","DOM","addNode","removeNode","node","nodeChildrenIds","updateNodesState","bind","update","x0","y0","x","y","treeData","nodes","imageWidth","imageHeight","imageBorderColor","imageBorderWidth","imageRx","imageCenterTopDistance","imageCenterLeftDistance","borderColor","width","height","links","patternsSelection","linkSelection","linkUpdate","o","linkEnter","nodesSelection","nodeEnter","nodeImageGroups","nodeUpdate","fo","nodeButtonGroups","param","nodeExitTransition","setTimeout","boundingRect","newX","window","newY","redraw","isEdge","rgbaObjToColor","red","green","blue","alpha","diagonal","s","ex","t","ey","xrvs","yrvs","rInitial","r","h","restyleForeignObjectElements","onButtonClick","setExpansionFlagToChildren","setExpanded","expandSomeNodes","parent","expand","findmySelf","zoomed","transform","OrganisationalChart","d3Container","useRef","useState","setChart","setId","useLayoutEffect","newChart","ref","value","onChange","e","onClick","App","state","setstate","useEffect","then","log","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.c0dc708f.chunk.js","sourcesContent":["const d3 = require('d3')\n\nclass TreeChart {\n  constructor() {\n    // Exposed variables\n    const attrs = {\n      id: `ID${Math.floor(Math.random() * 1000000)}`, // Id for event handlings\n      svgWidth: 100,\n      svgHeight: 100,\n      marginTop: 0,\n      marginBottom: 0,\n      marginRight: 0,\n      marginLeft: 0,\n      container: 'body',\n      defaultTextFill: '#2C3E50',\n      nodeTextFill: 'white',\n      defaultFont: 'Helvetica',\n      backgroundColor: '#fafafa',\n      data: null,\n      depth: 180,\n      duration: 600,\n      strokeWidth: 3,\n      dropShadowId: null,\n      initialZoom: 1,\n      minMaxZoomProportions: [0.05, 3],\n      behaviors: null,\n      root: {},\n      onNodeClick: (d) => d\n    }\n\n    this.getChartState = () => attrs\n\n    // Dynamically set getter and setter functions for Chart class\n    Object.keys(attrs).forEach((key) => {\n      this[key] = function (_) {\n        var string = `attrs['${key}'] = _`\n        if (!arguments.length) {\n          return eval(`attrs['${key}'];`)\n        }\n        eval(string)\n        return this\n      }\n    })\n\n    this.initializeEnterExitUpdatePattern()\n  }\n\n  initializeEnterExitUpdatePattern() {\n    d3.selection.prototype.patternify = function (params) {\n      var container = this\n      var selector = params.selector\n      var elementTag = params.tag\n      var data = params.data || [selector]\n\n      // Pattern in action\n      var selection = container.selectAll('.' + selector).data(data, (d, i) => {\n        if (typeof d === 'object') {\n          if (d.id) {\n            return d.id\n          }\n        }\n        return i\n      })\n      selection.exit().remove()\n      selection = selection.enter().append(elementTag).merge(selection)\n      selection.attr('class', selector)\n      return selection\n    }\n  }\n\n  // This method retrieves passed node's children IDs (including node)\n  getNodeChildrenIds({ data, children, _children }, nodeIdsStore) {\n    // Store current node ID\n    nodeIdsStore.push(data.nodeId)\n\n    // Loop over children and recursively store descendants id (expanded nodes)\n    if (children) {\n      children.forEach((d) => {\n        this.getNodeChildrenIds(d, nodeIdsStore)\n      })\n    }\n\n    // Loop over _children and recursively store descendants id (collapsed nodes)\n    if (_children) {\n      _children.forEach((d) => {\n        this.getNodeChildrenIds(d, nodeIdsStore)\n      })\n    }\n\n    // Return result\n    return nodeIdsStore\n  }\n\n  locateRecursive = (d, id) => {\n    const locateRecurve = this.locateRecursive\n\n    if (d.id === id) {\n      this.expandParents(d)\n    } else if (d._children) {\n      d._children.forEach(function (ch) {\n        ch.parent = d\n        locateRecurve(ch, id)\n      })\n    } else if (d.children) {\n      d.children.forEach(function (ch) {\n        ch.parent = d\n        locateRecurve(ch, id)\n      })\n    }\n  }\n\n  locate(id) {\n    const attrs = this.getChartState()\n    const locateRecurve = this.locateRecursive\n    /* collapse all and expand logged user nodes */\n    if (!attrs.root.children) {\n      if (!attrs.root.id === id) {\n        attrs.root.children = attrs.root._children\n      }\n    }\n    if (attrs.root.children) {\n      attrs.root.children.forEach(this.collapse)\n      attrs.root.children.forEach(function (ch) {\n        locateRecurve(ch, id)\n      })\n    }\n\n    this.update(attrs.root, { locate: id })\n  }\n\n  // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale\n  setZoomFactor(zoomLevel) {\n    const attrs = this.getChartState()\n    const calc = attrs.calc\n\n    // Store passed zoom level\n    attrs.initialZoom = zoomLevel\n\n    // Rescale container element accordingly\n    attrs.centerG.attr(\n      'transform',\n      ` translate(${calc.centerX}, ${calc.nodeMaxHeight / 2}) scale(${\n        attrs.initialZoom\n      })`\n    )\n  }\n\n  render() {\n    // InnerFunctions which will update visuals\n\n    const attrs = this.getChartState()\n    const thisObjRef = this\n    // Drawing containers\n    const container = d3.select(attrs.container)\n    const containerRect = container.node().getBoundingClientRect()\n    // if (containerRect.width > 0) attrs.svgWidth = containerRect.width\n\n    // Attach drop shadow id to attrs object\n    this.setDropShadowId(attrs)\n\n    // Calculated properties\n    const calc = {\n      id: null,\n      chartTopMargin: null,\n      chartLeftMargin: null,\n      chartWidth: null,\n      chartHeight: null\n    }\n    calc.id = `ID${Math.floor(Math.random() * 1000000)}` // id for event handlings\n    calc.chartLeftMargin = attrs.marginLeft\n    calc.chartTopMargin = attrs.marginTop\n    calc.chartWidth = attrs.svgWidth - attrs.marginRight - calc.chartLeftMargin\n    calc.chartHeight =\n      attrs.svgHeight - attrs.marginBottom - calc.chartTopMargin\n    attrs.calc = calc\n\n    // Get maximum node width and height\n    calc.nodeMaxWidth = d3.max(attrs.data, ({ width }) => width)\n    calc.nodeMaxHeight = d3.max(attrs.data, ({ height }) => height)\n\n    // Calculate max node depth (it's needed for layout heights calculation)\n    attrs.depth = calc.nodeMaxHeight + 100\n    calc.centerX = calc.chartWidth / 2\n\n    //* *******************  LAYOUTS  ***********************\n    const layouts = {\n      treemap: null\n    }\n    attrs.layouts = layouts\n\n    // Generate tree layout function\n    layouts.treemap = d3\n      .tree()\n      .size([calc.chartWidth, calc.chartHeight])\n      .nodeSize([calc.nodeMaxWidth + 100, calc.nodeMaxHeight + attrs.depth])\n\n    // ******************* BEHAVIORS . **********************\n    const behaviors = {\n      zoom: null\n    }\n\n    // Get zooming function\n    behaviors.zoom = d3.zoom().on('zoom', (d) => this.zoomed(d))\n\n    attrs.behaviors = behaviors\n    //* ***************** ROOT node work ************************\n\n    // Convert flat data to hierarchical\n    attrs.root = d3\n      .stratify()\n      .id(({ nodeId }) => nodeId)\n      .parentId(({ parentNodeId }) => parentNodeId)(attrs.data)\n\n    // Set child nodes enter appearance positions\n    attrs.root.x0 = 0\n    attrs.root.y0 = 0\n\n    /** Get all nodes as array (with extended parent & children properties set)\n            This way we can access any node's parent directly using node.parent - pretty cool, huh?\n        */\n    attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants()\n\n    // Assign direct children and total subordinate children's cound\n    attrs.allNodes.forEach((d) => {\n      Object.assign(d.data, {\n        directSubordinates: d.children ? d.children.length : 0,\n        totalSubordinates: d.descendants().length - 1\n      })\n    })\n\n    // Collapse all children at first\n    attrs.root.children.forEach((d) => this.collapse(d))\n\n    // Then expand some nodes, which have `expanded` property set\n    attrs.root.children.forEach((d) => this.expandSomeNodes(d))\n\n    // *************************  DRAWING **************************\n    // Add svg\n    console.log('svg', attrs.svgWidth, attrs.svgHeight)\n    const svg = container\n      .patternify({\n        tag: 'svg',\n        selector: 'svg-chart-container'\n      })\n      .attr('width', attrs.svgWidth)\n      .attr('height', attrs.svgHeight)\n      .attr('font-family', attrs.defaultFont)\n      .call(behaviors.zoom)\n      .attr('cursor', 'move')\n      .style('background-color', attrs.backgroundColor)\n    attrs.svg = svg\n\n    // Add container g element\n    const chart = svg\n      .patternify({\n        tag: 'g',\n        selector: 'chart'\n      })\n      .attr(\n        'transform',\n        `translate(${calc.chartLeftMargin},${calc.chartTopMargin})`\n      )\n\n    // Add one more container g element, for better positioning controls\n    attrs.centerG = chart\n      .patternify({\n        tag: 'g',\n        selector: 'center-group'\n      })\n      .attr(\n        'transform',\n        `translate(${calc.centerX},${calc.nodeMaxHeight / 2}) scale(${\n          attrs.initialZoom\n        })`\n      )\n\n    attrs.chart = chart\n\n    // ************************** ROUNDED AND SHADOW IMAGE  WORK USING SVG FILTERS **********************\n\n    // Adding defs element for rounded image\n    attrs.defs = svg.patternify({\n      tag: 'defs',\n      selector: 'image-defs'\n    })\n\n    // Adding defs element for image's shadow\n    const filterDefs = svg.patternify({\n      tag: 'defs',\n      selector: 'filter-defs'\n    })\n\n    // Adding shadow element - (play with svg filter here - https://bit.ly/2HwnfyL)\n    const filter = filterDefs\n      .patternify({\n        tag: 'filter',\n        selector: 'shadow-filter-element'\n      })\n      .attr('id', attrs.dropShadowId)\n      .attr('y', `${-50}%`)\n      .attr('x', `${-50}%`)\n      .attr('height', `${200}%`)\n      .attr('width', `${200}%`)\n\n    // Add gaussian blur element for shadows - we can control shadow length with this\n    filter\n      .patternify({\n        tag: 'feGaussianBlur',\n        selector: 'feGaussianBlur-element'\n      })\n      .attr('in', 'SourceAlpha')\n      .attr('stdDeviation', 3.1)\n      .attr('result', 'blur')\n\n    // Add fe-offset element for shadows -  we can control shadow positions with it\n    filter\n      .patternify({\n        tag: 'feOffset',\n        selector: 'feOffset-element'\n      })\n      .attr('in', 'blur')\n      .attr('result', 'offsetBlur')\n      .attr('dx', 4.28)\n      .attr('dy', 4.48)\n      .attr('x', 8)\n      .attr('y', 8)\n\n    // Add fe-flood element for shadows - we can control shadow color and opacity with this element\n    filter\n      .patternify({\n        tag: 'feFlood',\n        selector: 'feFlood-element'\n      })\n      .attr('in', 'offsetBlur')\n      .attr('flood-color', 'black')\n      .attr('flood-opacity', 0.3)\n      .attr('result', 'offsetColor')\n\n    // Add feComposite element for shadows\n    filter\n      .patternify({\n        tag: 'feComposite',\n        selector: 'feComposite-element'\n      })\n      .attr('in', 'offsetColor')\n      .attr('in2', 'offsetBlur')\n      .attr('operator', 'in')\n      .attr('result', 'offsetBlur')\n\n    // Add feMerge element for shadows\n    const feMerge = filter.patternify({\n      tag: 'feMerge',\n      selector: 'feMerge-element'\n    })\n\n    // Add feMergeNode element for shadows\n    feMerge\n      .patternify({\n        tag: 'feMergeNode',\n        selector: 'feMergeNode-blur'\n      })\n      .attr('in', 'offsetBlur')\n\n    // Add another feMergeNode element for shadows\n    feMerge\n      .patternify({\n        tag: 'feMergeNode',\n        selector: 'feMergeNode-graphic'\n      })\n      .attr('in', 'SourceGraphic')\n\n    // Display tree contenrs\n    this.update(attrs.root)\n\n    // #########################################  UTIL FUNCS ##################################\n    // This function restyles foreign object elements ()\n\n    d3.select(window).on(`resize.${attrs.id}`, () => {\n      const containerRect = container.node().getBoundingClientRect()\n      //  if (containerRect.width > 0) attrs.svgWidth = containerRect.width;\n      //\tmain();\n    })\n\n    return this\n  }\n\n  // This function sets drop shadow ID to the passed object\n  setDropShadowId(d) {\n    // If it's already set, then return\n    if (d.dropShadowId) return\n\n    // Generate drop shadow ID\n    let id = `${d.id}-drop-shadow`\n\n    // If DOM object is available, then use UID method to generated shadow id\n    // @ts-ignore\n    if (typeof DOM !== 'undefined') {\n      // @ts-ignore\n      id = DOM.uid(d.id).id\n    }\n\n    // Extend passed object with drop shadow ID\n    Object.assign(d, {\n      dropShadowId: id\n    })\n  }\n\n  // This function can be invoked via chart.addNode API, and it adds node in tree at runtime\n  addNode(obj) {\n    const attrs = this.getChartState()\n    attrs.data.push(obj)\n\n    // Update state of nodes and redraw graph\n    this.updateNodesState()\n    return this\n  }\n\n  // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime\n  removeNode(nodeId) {\n    const attrs = this.getChartState()\n    const node = attrs.allNodes.filter(({ data }) => data.nodeId == nodeId)[0]\n\n    // Remove all node childs\n    if (node) {\n      // Retrieve all children nodes ids (including current node itself)\n      const nodeChildrenIds = this.getNodeChildrenIds(node, [])\n\n      // Filter out retrieved nodes and reassign data\n      attrs.data = attrs.data.filter((d) => !nodeChildrenIds.includes(d.nodeId))\n\n      const updateNodesState = this.updateNodesState.bind(this)\n      // Update state of nodes and redraw graph\n      updateNodesState()\n    }\n  }\n\n  // This function basically redraws visible graph, based on nodes state\n  update({ x0, y0, x, y }, param) {\n    const attrs = this.getChartState()\n    const calc = attrs.calc\n\n    //  Assigns the x and y position for the nodes\n    const treeData = attrs.layouts.treemap(attrs.root)\n\n    // Get tree nodes and links and attach some properties\n    const nodes = treeData.descendants().map((d) => {\n      // If at least one property is already set, then we don't want to reset other properties\n      if (d.width) return d\n\n      // Declare properties with deffault values\n      let imageWidth = 100\n      let imageHeight = 100\n      let imageBorderColor = 'steelblue'\n      let imageBorderWidth = 0\n      let imageRx = 0\n      let imageCenterTopDistance = 0\n      let imageCenterLeftDistance = 0\n      let borderColor = 'steelblue'\n      let backgroundColor = 'steelblue'\n      const width = d.data.width\n      const height = d.data.height\n      let dropShadowId = `none`\n\n      // Override default values based on data\n      if (d.data.nodeImage && d.data.nodeImage.shadow) {\n        dropShadowId = `url(#${attrs.dropShadowId})`\n      }\n      if (d.data.nodeImage && d.data.nodeImage.width) {\n        imageWidth = d.data.nodeImage.width\n      }\n      if (d.data.nodeImage && d.data.nodeImage.height) {\n        imageHeight = d.data.nodeImage.height\n      }\n      if (d.data.nodeImage && d.data.nodeImage.borderColor) {\n        imageBorderColor = this.rgbaObjToColor(d.data.nodeImage.borderColor)\n      }\n      if (d.data.nodeImage && d.data.nodeImage.borderWidth) {\n        imageBorderWidth = d.data.nodeImage.borderWidth\n      }\n      if (d.data.nodeImage && d.data.nodeImage.centerTopDistance) {\n        imageCenterTopDistance = d.data.nodeImage.centerTopDistance\n      }\n      if (d.data.nodeImage && d.data.nodeImage.centerLeftDistance) {\n        imageCenterLeftDistance = d.data.nodeImage.centerLeftDistance\n      }\n      if (d.data.borderColor) {\n        borderColor = this.rgbaObjToColor(d.data.borderColor)\n      }\n      if (d.data.backgroundColor) {\n        backgroundColor = this.rgbaObjToColor(d.data.backgroundColor)\n      }\n      if (\n        d.data.nodeImage &&\n        d.data.nodeImage.cornerShape.toLowerCase() === 'circle'\n      ) {\n        imageRx = Math.max(imageWidth, imageHeight)\n      }\n      if (\n        d.data.nodeImage &&\n        d.data.nodeImage.cornerShape.toLowerCase() === 'rounded'\n      ) {\n        imageRx = Math.min(imageWidth, imageHeight) / 6\n      }\n\n      // Extend node object with calculated properties\n      return Object.assign(d, {\n        imageWidth,\n        imageHeight,\n        imageBorderColor,\n        imageBorderWidth,\n        borderColor,\n        backgroundColor,\n        imageRx,\n        width,\n        height,\n        imageCenterTopDistance,\n        imageCenterLeftDistance,\n        dropShadowId\n      })\n    })\n\n    // Get all links\n    const links = treeData.descendants().slice(1)\n\n    // Set constant depth for each nodes\n    nodes.forEach((d) => (d.y = d.depth * attrs.depth))\n\n    // ------------------- FILTERS ---------------------\n\n    // Add patterns for each node (it's needed for rounded image implementation)\n    const patternsSelection = attrs.defs\n      .selectAll('.pattern')\n      .data(nodes, ({ id }) => id)\n\n    // Define patterns enter selection\n    const patternEnterSelection = patternsSelection.enter().append('pattern')\n\n    // Patters update selection\n    const patterns = patternEnterSelection\n      .merge(patternsSelection)\n      .attr('class', 'pattern')\n      .attr('height', 1)\n      .attr('width', 1)\n      .attr('id', ({ id }) => id)\n\n    // Add images to patterns\n    const patternImages = patterns\n      .patternify({\n        tag: 'image',\n        selector: 'pattern-image',\n        data: (d) => [d]\n      })\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('height', ({ imageWidth }) => imageWidth)\n      .attr('width', ({ imageHeight }) => imageHeight)\n      .attr('xlink:href', ({ data }) => data.nodeImage && data.nodeImage.url)\n      .attr(\n        'viewbox',\n        ({ imageWidth, imageHeight }) => `0 0 ${imageWidth * 2} ${imageHeight}`\n      )\n      .attr('preserveAspectRatio', 'xMidYMin slice')\n\n    // Remove patterns exit selection after animation\n    patternsSelection.exit().transition().duration(attrs.duration).remove()\n\n    // --------------------------  LINKS ----------------------\n    // Get links selection\n    const linkSelection = attrs.centerG\n      .selectAll('path.link')\n      .data(links, ({ id }) => id)\n\n    // Enter any new links at the parent's previous position.\n    const linkEnter = linkSelection\n      .enter()\n      .insert('path', 'g')\n      .attr('class', 'link')\n      .attr('d', (d) => {\n        const o = {\n          x: x0,\n          y: y0\n        }\n        return this.diagonal(o, o)\n      })\n\n    // Get links update selection\n    const linkUpdate = linkEnter.merge(linkSelection)\n\n    // Styling links\n    linkUpdate\n      .attr('fill', 'none')\n      .attr('stroke-width', ({ data }) => data.connectorLineWidth || 2)\n      .attr('stroke', ({ data }) => {\n        if (data.connectorLineColor) {\n          return this.rgbaObjToColor(data.connectorLineColor)\n        }\n        return 'green'\n      })\n      .attr('stroke-dasharray', ({ data }) => {\n        if (data.dashArray) {\n          return data.dashArray\n        }\n        return ''\n      })\n\n    // Transition back to the parent element position\n    linkUpdate\n      .transition()\n      .duration(attrs.duration)\n      .attr('d', (d) => this.diagonal(d, d.parent))\n\n    // Remove any  links which is exiting after animation\n    const linkExit = linkSelection\n      .exit()\n      .transition()\n      .duration(attrs.duration)\n      .attr('d', (d) => {\n        const o = {\n          x: x,\n          y: y\n        }\n        return this.diagonal(o, o)\n      })\n      .remove()\n\n    // --------------------------  NODES ----------------------\n    // Get nodes selection\n    const nodesSelection = attrs.centerG\n      .selectAll('g.node')\n      .data(nodes, ({ id }) => id)\n\n    // Enter any new nodes at the parent's previous position.\n    const nodeEnter = nodesSelection\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .attr('transform', (d) => `translate(${x0},${y0})`)\n      .attr('cursor', 'pointer')\n      .on('click', ({ data }) => {\n        if ([...d3.event.srcElement.classList].includes('node-button-circle')) {\n          return\n        }\n        attrs.onNodeClick(data.nodeId)\n      })\n\n    // Add background rectangle for the nodes\n    nodeEnter\n      .patternify({\n        tag: 'rect',\n        selector: 'node-rect',\n        data: (d) => [d]\n      })\n      .style('fill', ({ _children }) => (_children ? 'lightsteelblue' : '#fff'))\n\n    // Defined node images wrapper group\n    const nodeImageGroups = nodeEnter.patternify({\n      tag: 'g',\n      selector: 'node-image-group',\n      data: (d) => [d]\n    })\n\n    // Add background rectangle for node image\n    nodeImageGroups.patternify({\n      tag: 'rect',\n      selector: 'node-image-rect',\n      data: (d) => [d]\n    })\n\n    // Node update styles\n    const nodeUpdate = nodeEnter\n      .merge(nodesSelection)\n      .style('font', '12px sans-serif')\n\n    // Add foreignObject element inside rectangle\n    const fo = nodeUpdate.patternify({\n      tag: 'foreignObject',\n      selector: 'node-foreign-object',\n      data: (d) => [d]\n    })\n\n    // Add foreign object\n    fo.patternify({\n      tag: 'xhtml:div',\n      selector: 'node-foreign-object-div',\n      data: (d) => [d]\n    })\n\n    this.restyleForeignObjectElements()\n\n    // Add Node button circle's group (expand-collapse button)\n    const nodeButtonGroups = nodeEnter\n      .patternify({\n        tag: 'g',\n        selector: 'node-button-g',\n        data: (d) => [d]\n      })\n      .on('click', (d) => this.onButtonClick(d))\n\n    // Add expand collapse button circle\n    nodeButtonGroups.patternify({\n      tag: 'circle',\n      selector: 'node-button-circle',\n      data: (d) => [d]\n    })\n\n    // Add button text\n    nodeButtonGroups\n      .patternify({\n        tag: 'text',\n        selector: 'node-button-text',\n        data: (d) => [d]\n      })\n      .attr('pointer-events', 'none')\n\n    // Transition to the proper position for the node\n    nodeUpdate\n      .transition()\n      .attr('opacity', 0)\n      .duration(attrs.duration)\n      .attr('transform', ({ x, y }) => `translate(${x},${y})`)\n      .attr('opacity', 1)\n\n    // Move images to desired positions\n    nodeUpdate\n      .selectAll('.node-image-group')\n      .attr('transform', ({ imageWidth, width, imageHeight, height }) => {\n        const x = -imageWidth / 2 - width / 2\n        const y = -imageHeight / 2 - height / 2\n        return `translate(${x},${y})`\n      })\n\n    // Style node image rectangles\n    nodeUpdate\n      .select('.node-image-rect')\n      .attr('fill', ({ id }) => `url(#${id})`)\n      .attr('width', ({ imageWidth }) => imageWidth)\n      .attr('height', ({ imageHeight }) => imageHeight)\n      .attr('stroke', ({ imageBorderColor }) => imageBorderColor)\n      .attr('stroke-width', ({ imageBorderWidth }) => imageBorderWidth)\n      .attr('rx', ({ imageRx }) => imageRx)\n      .attr('y', ({ imageCenterTopDistance }) => imageCenterTopDistance)\n      .attr('x', ({ imageCenterLeftDistance }) => imageCenterLeftDistance)\n      .attr('filter', ({ dropShadowId }) => dropShadowId)\n\n    // Style node rectangles\n    nodeUpdate\n      .select('.node-rect')\n      .attr('width', ({ data }) => data.width)\n      .attr('height', ({ data }) => data.height)\n      .attr('x', ({ data }) => -data.width / 2)\n      .attr('y', ({ data }) => -data.height / 2)\n      .attr('rx', ({ data }) => data.borderRadius || 0)\n      .attr('stroke-width', ({ data }) => {\n        if (param && data.nodeId === param.locate) {\n          return '10'\n        }\n        return data.borderWidth || attrs.strokeWidth\n      })\n      .attr('cursor', 'pointer')\n      .attr('stroke', ({ borderColor, data }) => {\n        if (param && data.nodeId === param.locate) {\n          return '#ff0000'\n        }\n        return borderColor\n      })\n      .attr('id', ({ data }) => data.nodeId)\n      .style('fill', ({ backgroundColor }) => backgroundColor)\n\n    // Move node button group to the desired position\n    nodeUpdate\n      .select('.node-button-g')\n      .attr('transform', ({ data }) => `translate(0,${data.height / 2})`)\n      .attr('opacity', ({ children, _children }) => {\n        if (children || _children) {\n          return 1\n        }\n        return 0\n      })\n\n    // Restyle node button circle\n    nodeUpdate\n      .select('.node-button-circle')\n      .attr('r', 16)\n      .attr('stroke-width', ({ data }) => data.borderWidth || attrs.strokeWidth)\n      .attr('fill', attrs.backgroundColor)\n      .attr('stroke', ({ borderColor }) => borderColor)\n\n    // Restyle button texts\n    nodeUpdate\n      .select('.node-button-text')\n      .attr('text-anchor', 'middle')\n      .attr('alignment-baseline', 'middle')\n      .attr('fill', attrs.defaultTextFill)\n      .attr('font-size', ({ children }) => {\n        if (children) return 40\n        return 26\n      })\n      .text(({ children }) => {\n        if (children) return '-'\n        return '+'\n      })\n      .attr('y', 0)\n\n    // Remove any exiting nodes after transition\n    const nodeExitTransition = nodesSelection\n      .exit()\n      .attr('opacity', 1)\n      .transition()\n      .duration(attrs.duration)\n      .attr('transform', (d) => `translate(${x},${y})`)\n      .on('end', function () {\n        d3.select(this).remove()\n      })\n      .attr('opacity', 0)\n\n    // On exit reduce the node rects size to 0\n    nodeExitTransition\n      .selectAll('.node-rect')\n      .attr('width', 10)\n      .attr('height', 10)\n      .attr('x', 0)\n      .attr('y', 0)\n\n    // On exit reduce the node image rects size to 0\n    nodeExitTransition\n      .selectAll('.node-image-rect')\n      .attr('width', 10)\n      .attr('height', 10)\n      .attr('x', ({ width }) => width / 2)\n      .attr('y', ({ height }) => height / 2)\n\n    // Store the old positions for transition.\n    nodes.forEach((d) => {\n      d.x0 = d.x\n      d.y0 = d.y\n    })\n\n    setTimeout(() => {\n      if (param && param.locate) {\n        let x\n        let y\n        let depth\n        nodes.forEach(function (d) {\n          if (d.id === param.locate) {\n            depth = d.depth\n            x = d.x\n            y = d.y\n          }\n        })\n\n        //\n        const boundingRect = d3.select('.chart').node().getBBox()\n        console.log(boundingRect.height)\n        const newX = -x + window.innerWidth / 2\n        const newY = -y + window.innerHeight / 2\n        console.log('x', newX)\n        console.log('Y', newY)\n        attrs.chart.attr('transform', `translate(${newX},${newY}) scale(1)`)\n      }\n    }, 1850)\n  }\n\n  redraw() {\n    const attrs = this.getChartState()\n    // console.log(\"here\", d3.event.translate, d3.event.scale);\n    attrs.svg.attr(\n      'transform',\n      'translate(' + d3.event.translate + ')' + ' scale(' + d3.event.scale + ')'\n    )\n  }\n\n  // This function detects whether current browser is edge\n  isEdge() {\n    return window.navigator.userAgent.includes('Edge')\n  }\n\n  /* Function converts rgba objects to rgba color string \n      {red:110,green:150,blue:255,alpha:1}  => rgba(110,150,255,1)\n    */\n  rgbaObjToColor({ red, green, blue, alpha }) {\n    return `rgba(${red},${green},${blue},${alpha})`\n  }\n\n  // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges?collection=@bumbeishvili/work-components\n  diagonal(s, t) {\n    // Calculate some variables based on source and target (s,t) coordinates\n    const x = s.x\n    const y = s.y\n    const ex = t.x\n    const ey = t.y\n    const xrvs = ex - x < 0 ? -1 : 1\n    const yrvs = ey - y < 0 ? -1 : 1\n    const rdef = 35\n    const rInitial = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef\n    const r = Math.abs(ey - y) / 2 < rInitial ? Math.abs(ey - y) / 2 : rInitial\n    const h = Math.abs(ey - y) / 2 - r\n    const w = Math.abs(ex - x) - r * 2\n\n    // Build the path\n    const path = `\n             M ${x} ${y}\n             L ${x} ${y + h * yrvs}\n             C  ${x} ${y + h * yrvs + r * yrvs} ${x} ${\n      y + h * yrvs + r * yrvs\n    } ${x + r * xrvs} ${y + h * yrvs + r * yrvs}\n             L ${x + w * xrvs + r * xrvs} ${y + h * yrvs + r * yrvs}\n             C ${ex}  ${y + h * yrvs + r * yrvs} ${ex}  ${\n      y + h * yrvs + r * yrvs\n    } ${ex} ${ey - h * yrvs}\n             L ${ex} ${ey}\n           `\n    // Return result\n    return path\n  }\n\n  restyleForeignObjectElements() {\n    const attrs = this.getChartState()\n\n    attrs.svg\n      .selectAll('.node-foreign-object')\n      .attr('width', ({ width }) => width)\n      .attr('height', ({ height }) => height)\n      .attr('x', ({ width }) => -width / 2)\n      .attr('y', ({ height }) => -height / 2)\n    attrs.svg\n      .selectAll('.node-foreign-object-div')\n      .style('width', ({ width }) => `${width}px`)\n      .style('height', ({ height }) => `${height}px`)\n      .style('color', 'white')\n      .html(({ data }) => data.template)\n  }\n\n  // Toggle children on click.\n  onButtonClick(d) {\n    // If childrens are expanded\n    if (d.children) {\n      // Collapse them\n      d._children = d.children\n      d.children = null\n\n      // Set descendants expanded property to false\n      this.setExpansionFlagToChildren(d, false)\n    } else {\n      // Expand children\n      d.children = d._children\n      d._children = null\n\n      // Set each children as expanded\n      d.children.forEach(({ data }) => (data.expanded = true))\n    }\n\n    // Redraw Graph\n    this.update(d)\n  }\n\n  // This function changes `expanded` property to descendants\n  setExpansionFlagToChildren({ data, children, _children }, flag) {\n    // Set flag to the current property\n    data.expanded = flag\n\n    // Loop over and recursively update expanded children's descendants\n    if (children) {\n      children.forEach((d) => {\n        this.setExpansionFlagToChildren(d, flag)\n      })\n    }\n\n    // Loop over and recursively update collapsed children's descendants\n    if (_children) {\n      _children.forEach((d) => {\n        this.setExpansionFlagToChildren(d, flag)\n      })\n    }\n  }\n\n  // This function can be invoked via chart.setExpanded API, it expands or collapses particular node\n  setExpanded(id, expandedFlag) {\n    const attrs = this.getChartState()\n    // Retrieve node by node Id\n    const node = attrs.allNodes.filter(({ data }) => data.nodeId == id)[0]\n\n    // If node exists, set expansion flag\n    if (node) node.data.expanded = expandedFlag\n\n    // First expand all nodes\n    attrs.root.children.forEach((d) => this.expand(d))\n\n    // Then collapse all nodes\n    attrs.root.children.forEach((d) => this.collapse(d))\n\n    // Then expand only the nodes, which were previously expanded, or have an expand flag set\n    attrs.root.children.forEach((d) => this.expandSomeNodes(d))\n\n    // Redraw graph\n    this.update(attrs.root)\n  }\n\n  // Method which only expands nodes, which have property set \"expanded=true\"\n  expandSomeNodes(d) {\n    // If node has expanded property set\n    if (d.data.expanded) {\n      // Retrieve node's parent\n      let parent = d.parent\n\n      // While we can go up\n      while (parent) {\n        // Expand all current parent's children\n        if (parent._children) {\n          parent.children = parent._children\n        }\n\n        // Replace current parent holding object\n        parent = parent.parent\n      }\n    }\n\n    // Recursivelly do the same for collapsed nodes\n    if (d._children) {\n      d._children.forEach((ch) => this.expandSomeNodes(ch))\n    }\n\n    // Recursivelly do the same for expanded nodes\n    if (d.children) {\n      d.children.forEach((ch) => this.expandSomeNodes(ch))\n    }\n  }\n\n  // This function updates nodes state and redraws graph, usually after data change\n  updateNodesState() {\n    const attrs = this.getChartState()\n    // Store new root by converting flat data to hierarchy\n    attrs.root = d3\n      .stratify()\n      .id(({ nodeId }) => nodeId)\n      .parentId(({ parentNodeId }) => parentNodeId)(attrs.data)\n\n    // Store positions, where children appear during their enter animation\n    attrs.root.x0 = 0\n    attrs.root.y0 = 0\n\n    // Store all nodes in flat format (although, now we can browse parent, see depth e.t.c. )\n    attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants()\n\n    // Store direct and total descendants count\n    attrs.allNodes.forEach((d) => {\n      Object.assign(d.data, {\n        directSubordinates: d.children ? d.children.length : 0,\n        totalSubordinates: d.descendants().length - 1\n      })\n    })\n\n    // Expand all nodes first\n    attrs.root.children.forEach(this.expand)\n\n    // Then collapse them all\n    attrs.root.children.forEach((d) => this.collapse(d))\n\n    // Then only expand nodes, which have expanded proprty set to true\n    attrs.root.children.forEach((ch) => this.expandSomeNodes(ch))\n\n    // Redraw Graphs\n    this.update(attrs.root)\n  }\n\n  // Function which collapses passed node and it's descendants\n  collapse = (d) => {\n    if (d.children) {\n      d._children = d.children\n      d._children.forEach((ch) => this.collapse(ch))\n      d.children = null\n    }\n  }\n\n  // Function which expands passed node and it's descendants\n  expand(d) {\n    if (d._children) {\n      d.children = d._children\n      d.children.forEach((ch) => this.expand(ch))\n      d._children = null\n    }\n  }\n\n  findmySelf(d) {\n    if (d.isLoggedUser) {\n      this.expandParents(d)\n    } else if (d._children) {\n      d._children.forEach(function (ch) {\n        ch.parent = d\n        this.findmySelf(ch)\n      })\n    } else if (d.children) {\n      d.children.forEach(function (ch) {\n        ch.parent = d\n        this.findmySelf(ch)\n      })\n    }\n  }\n\n  expandParents = (d) => {\n    while (d.parent) {\n      d = d.parent\n      if (!d.children) {\n        d.children = d._children\n        d._children = null\n      }\n    }\n  }\n\n  // Zoom handler function\n  zoomed() {\n    const attrs = this.getChartState()\n    const chart = attrs.chart\n\n    // Get d3 event's transform object\n    const transform = d3.event.transform\n\n    // Store it\n    attrs.lastTransform = transform\n    chart.attr('transform', transform)\n\n    // Apply new styles to the foreign object element\n    if (this.isEdge()) {\n      this.restyleForeignObjectElements()\n    }\n  }\n\n  // Added helper functions\n}\n\nexport default TreeChart\n","import React, { useLayoutEffect, useRef, useState } from 'react'\nimport TreeChart from './chartHelper/index'\nimport styles from './styles.module.css'\n\nexport const OrganisationalChart = ({ data, onNodeClick }) => {\n  const d3Container = useRef(null)\n  const [chart, setChart] = useState(null)\n  const [id, setId] = useState('O-498')\n\n  useLayoutEffect(() => {\n    if (data && d3Container.current) {\n      let newChart\n      if (!chart) {\n        newChart = new TreeChart()\n      }\n      console.log(data)\n\n      newChart\n        .container(d3Container.current)\n        .data(data)\n        .svgWidth(1000)\n        .svgHeight(500)\n        .initialZoom(0.4)\n        .onNodeClick((d) => {\n          console.log(d + ' node clicked')\n          onNodeClick(d)\n        })\n        .render()\n      setChart(newChart)\n    }\n  }, [data, d3Container.current])\n  if (chart) {\n    console.log(chart)\n    // chart.locate('O-917')\n  }\n  return (\n    <div>\n      <div ref={d3Container} />\n      <input\n        value={id}\n        onChange={(e) => {\n          setId(`${e.target.value}`)\n        }}\n      />\n      <button onClick={() => chart.locate(id)}>Locate</button>\n    </div>\n  )\n}\n","import React, {useEffect, useState} from 'react'\nimport * as d3 from 'd3';\nimport { OrganisationalChart } from 'react-org-chart'\nimport 'react-org-chart/dist/index.css'\n\nconst App = () => {\nconst [state, setstate] = useState(null)\n  useEffect(() => {\n    d3.json(\n      'https://gist.githubusercontent.com/bumbeishvili/dc0d47bc95ef359fdc75b63cd65edaf2/raw/c33a3a1ef4ba927e3e92b81600c8c6ada345c64b/orgChart.json',\n    ).then(data => {\n      setstate(data);\n    });\n  }, []);\n\n\n  return <OrganisationalChart \n  \n  data={state}\n  onNodeClick={node=>console.log(node)} />\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}